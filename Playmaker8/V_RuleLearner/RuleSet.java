
package V_RuleLearner;

import V_Sensors.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.concurrent.atomic.AtomicInteger;

/**
 *
 * @author virgile
 */
public class RuleSet {
    
    
    public ArrayList <Integer> references;
    public ArrayList <Integer> indexesOfPrec;
    public ArrayList <Integer> precedences;
    private RuleList rulelist;
    private SensorList sList;
    public double totalProb;
    public static AtomicInteger counter = new AtomicInteger();
    public int id;

    
    
    /*
        RULESET CONTAINS RULES WITH THE SAME PRECONDITION.
        WHEN CREATED, A UNIQUE ID IS GENERATED BY ATOMIC INTEGER.
        WHEN CREATED, TOTALPROB = -1, IT IS WHEN ADDING RULES TO RULESETS 
        THAT THE PROB IS CALCULATED.
    */
    public RuleSet (RuleList rulelist, SensorList sList) {
        
        this.references = new ArrayList();
        this.rulelist = rulelist;
        this.totalProb = -1.0;
        this.id = counter.incrementAndGet();
        this.indexesOfPrec = new ArrayList();
        this.precedences = new ArrayList ();
        this.sList = sList;
    }

    
    // BUILDS A RULESET FROM TWO RULESETS, IN ORDER TO MEASURE THE ERROR, AND
    // SET PRECEDENCE FROM ONE OVER ANOTHER 
    public RuleSet (RuleSet RS1, RuleSet RS2, SensorList sList, SensorMap sMap, RuleMap rMap) {
        
        // CREATING COMBINATION RULESET FROM RS1 & RS2
        
        this.references = new ArrayList();
        this.sList = sList;
        this.rulelist = RS1.rulelist;
        this.totalProb = 0.0;
        this.id = counter.incrementAndGet();
        this.precedences = new ArrayList ();
        Sensor precondition = RS1.getPrecursorWithID().merge(RS2.getPrecursorWithID());

        
        ArrayList <Integer> common_non_wildcarded_indexes = RS1.getSuccessor().detectCommonNonWilcardedIndexes(RS2.getSuccessor());

        Sensor root = new Sensor(RS1.getPrecursorWithID().tokenMap);
        
        int number = common_non_wildcarded_indexes.size();
        
        boolean insert;
        
        // THERE IS A CONFLICT ONLY IF SOME COMMON NON WILDCARDED INDEXES EXIST
        if (number >= 1) {
            SensorList conflicted_indexes_list = root.expand(common_non_wildcarded_indexes.get(0));
            
            if (number >= 2) { 
                
                // Expanding the conflicted indexes in ArrayList
                for (int h = 2; h<=number; h++) {
                    
                    conflicted_indexes_list.expandListAt(common_non_wildcarded_indexes.get(h-1));
                }
            }
            
            for (int j = 0; j < conflicted_indexes_list.size(); j++) {
                
                // We only need to insert the Rules with postcondition corresponding to either RS1 or RS2
                //
                // So we check for post. matches in the first and then second RuleSet
                insert = false;

                        // SEARCHING FOR MATCH IN FIRST RULESET
                        for (int h1 = 0; h1 < RS1.size(); h1++) {
                            ///
                            if (RS1.getSuccessor(h1).sensorMatch(conflicted_indexes_list.getSensor(j+1))) {
                                insert = true;
                                
                                break;
                            }
                        }
                        
                        // SEARCHING FOR MATCH IN SECOND RULESET
                        if (!insert) {
                            
                            for (int h2 = 0; h2 < RS2.size(); h2++) {
                            
                                
                                if (RS2.getSuccessor(h2).sensorMatch(conflicted_indexes_list.getSensor(j+1))) {
                                    insert = true;
                                    
                                    break;
                                }
                                

                            }
                        }
                        
                        // If the Rule postcondition was found in RS1 or RS2, we shall create it
                        if (insert) {
                            
                            Rule rule = new Rule(precondition, conflicted_indexes_list.getSensor(j+1));
                            
                            rule.ruleset_id = this.id;
                            
                            int aa = sMap.getMatchingOccurencies(precondition);
                            
                            int tt  = rMap.getMatchingOccurencies(rule);
                            
                            
                            rule.prec_occurrencies = aa;
                            rule.occurrencies = tt;
                            
                            this.rulelist.addRule(rule);
                            this.add(rule);
                           
                        }
                    
            }
            
        }
        
        
        // UPDATING RULESET PROBABILITY
        if (this.size() > 0) {
            for (int i = 0; i < this.size(); i++) {

                totalProb = totalProb + this.getRule(i).getProb();
                totalProb = Math.round(totalProb * 1000);
                totalProb = totalProb/1000;
                
            }
        }
        
    }    


    // Custom made Error Algorithm to determine which RuleSet precedes
    public double getError (RuleSet RS) {
        
        double a = -0.0;
        
        
        if (RS.getSuccessor().numberOfNonWildcards() == this.getSuccessor().numberOfNonWildcards()) {
            for (int i = 0; i < RS.size(); i++) {

                for (int j = 0; j < this.size(); j++) {

                    if (this.getSuccessor(j).sensorMatch(RS.getSuccessor(i))) {

                        if (this.getRule(j).getProb() == 0.0) {

                            a = a + 0.5;
                            break;
                        }
                        else {
                            a = a + Math.abs(this.getRule(j).getProb() - RS.getRule(i).getProb());
                            break;
                        }
                    }
                }
            }

            return a;
        }
        
        else {
            
            for (int j = 0; j < this.size(); j++) {
            
                for (int i = 0; i < RS.size(); i++) {

                

                    if (this.getSuccessor(j).sensorMatch(RS.getSuccessor(i))) {

                        if (this.getRule(j).getProb() == 0.0) {

                            a = a + 0.5;
                            break;
                        }
                        else {
                            double b = RS.getRule(i).getProb();
                            
                            if (i+1 < RS.size()) {
                                for (int h = i+1; h < RS.size(); h++) {

                                    if (this.getSuccessor(j).sensorMatch(RS.getSuccessor(h)))
                                        b = b + RS.getRule(h).getProb();
                                }
                                a = a + Math.abs(this.getRule(j).getProb() - b);
                                break;
                            }
                        }

                    }
                }
            }

            return a;
        }
        
    }
    
    // Returns true if RS1 precedes over RS2, false otherwise
    public boolean precedingOver (RuleSet RS1, RuleSet RS2) {
        
        return (this.getError(RS1) < this.getError(RS2));
    }
    
    
    public void add (int a) {
        
        references.add(a);
    }
    
    public void add (Rule r) {
        

        references.add(r.id);
    }
    
    
    
    public void initIndexes (SensorMap sMap) {
        
        if (this.size() >= 1)
        indexesOfPrec = sList.indexesOfSensor(this.getPrecursorWithID());
        
        //indexesOfPrec = sMap.getIndexes(id);
        
    }
    
    
    public Rule getRule (int i) {
        
        return this.rulelist.getRuleByID(this.references.get(i));
    }
    
    
    @Override
    public String toString () {
        
        return this.references.toString();
    }
    
    public int size () {
        
        return references.size();
    }
    
    
    // Returns the Precursor of a Rule using IDS
    public Sensor getPrecursorWithID () {
        
        return this.rulelist.getRuleByID(this.references.get(0)).precondition;
    }
   
    // Returns the Precursor Occurrencies of a Rule using IDS
    public int getPrecursorOccurrencies () {
        
        return this.rulelist.getRuleByID(this.references.get(0)).prec_occurrencies;
    }
    
    
    public Sensor getSuccessor () {
        
        return getSuccessor(0);
    }
    
    // WORKS WITH IDS
    public Sensor getSuccessor (int i) {
        
        return this.rulelist.getRuleByID(this.references.get(i)).postcondition;
    }    
    

    
    // Returns the Non-Wildcarded Indexes of the Successor 
    public ArrayList <Integer> detectNonWildcardedSpots () {
        
        ArrayList <Integer> res = new ArrayList (); 
        
        for (int i = 0; i < this.getSuccessor().size(); i++) {
            
            if (this.getSuccessor().getToken(i).isNotWildcard())
                res.add(i);
        }
        
        return res;       
    }

    
    public void print () {
        
        System.out.println("PRINTING RULESET ID : " + this.id + " (" + this.size() + ") entries.");
        for (int i = 0; i < this.size(); i++) {
            
            System.out.println("Ruleset " + (i+1) + " : " + references.get(i) );
        }
        System.out.println("Total Prob : " + this.totalProb);
    }
 
    
    // MORE DETAILED WAY TO PRINT A RULESET, PRINTING RULES CONTENT INSTEAD OF IDS
    public void printRules () {
        
        System.out.println("PRINTING RULESET ID : " + this.id + " (" + this.size() + ") entries.");
        for (int i = 0; i < this.size(); i++) {
            
            System.out.println("Rule " + (i+1) + " (ID " + references.get(i) + ") : " + this.rulelist.getRuleByID(references.get(i)) + " Prob : " + this.rulelist.getRuleByID(references.get(i)).getProb() + " TIMES " + this.rulelist.getRuleByID(references.get(i)).occurrencies + " PREC " + this.rulelist.getRuleByID(references.get(i)).prec_occurrencies);
        }
        System.out.println("Total Prob : " + this.totalProb);
        System.out.println("Precedences : " + this.precedences);
    }
 
    
    
    // MORE DETAILED WAY TO PRINT A RULESET, PRINTING RULES CONTENT INSTEAD OF IDS
    public void printRules_RVLR () {
        
        System.out.println("PRINTING RULESET ID : " + this.id + " (" + this.size() + ") entries.");
        for (int i = 0; i < this.size(); i++) {
            
            System.out.println("Rule " + (i+1) + " (ID " + references.get(i) + ") : " + this.rulelist.getRuleByID(references.get(i)) + " Prob : " + this.rulelist.getRuleByID(references.get(i)).getProb() + " TIMES " + this.rulelist.getRuleByID(references.get(i)).occurrencies + " PREC " + this.rulelist.getRuleByID(references.get(i)).prec_occurrencies + " Value : " + this.rulelist.getRuleByID(references.get(i)).get_RVRL());
        }
        System.out.println("Total Prob : " + this.totalProb);
        //System.out.println("Precedences : " + this.precedences);
    }    
    
    // CHECKS IF A RULESET IS CONFLICTING WITH ANOTHER ONE BY CHECKING SUCCESSORS OUTPUT
    public boolean isConflicting (RuleSet ruleset) {
        
        if (this.id == ruleset.id)
            return false; 
        
        if (!this.getPrecursorWithID().sensorMatch(ruleset.getPrecursorWithID()))
            return false;
        
        
        for (int i = 0; i < this.getSuccessor().size(); i++) {
            
            if ((this.getSuccessor().getToken(i).isNotWildcard()) && (ruleset.getSuccessor().getToken(i).isNotWildcard())) {
                
                //if (this.getPrecursorOccurrencies() <= ruleset.getPrecursorOccurrencies())
                    return true; 
            }
        }
        
        
        return false;
    }
    
    
    // MERGING SENSORS FROM RULESETS IN ORDER TO GET ALL THE POSSIBLE COMBINATIONS. 
    //
    // NO CLEANING OR PRUNING IS DONE HERE, WHICH MEANS SOME "IMPOSSIBLE" RULES CAN OCCUR.       
    public SensorList outputsFromRuleSets (RuleSet ruleset2) {
        
        SensorList res = new SensorList (); 

        for (int i = 0; i < this.size(); i++) {
            
            
            for (int j = 0; j < ruleset2.size(); j++) {
                
                Sensor a = this.getSuccessor(i).merge(ruleset2.getSuccessor(j));
                res.addSensor(a);
            }
        }
        
        return res;
    }

    
    //GETS PROBS OF THE OUTPUTSTATES
    public ArrayList <Double> outputsProbFromRuleSets (RuleSet ruleset2) {
        
        ArrayList <Double> res = new ArrayList <> (); 
        double a;
        
        for (int i = 0; i < this.size(); i++) {
            
            
            for (int j = 0; j < ruleset2.size(); j++) {
                
                a = this.getRule(i).getProb();
                a = a * ruleset2.getRule(j).getProb();
                res.add(a);
            }
        }
        
        return res;
    } 
    
   
    
    // CONSOLIDATES A RULESET BY ADDING MISSING RULES, 
    // IN ORDER TO GET A "COMPLETE" RULESET, I.E. WITH A TOTAL PROB OF 1. 
    //    
    // THIS PROCESS TOOK A HUGE TIME, WITH A BIT OF OPTIMIZATION WE DRASTICALLY
    // REDUCED THE EXECUTUION THE TIME NEEDED
    public int consolidate (RuleList closedList, RuleMap rMap) {
        
        int steps = 0;
        boolean insert;
        // IF THE RULESET IS ALREADY COMPLETE, NO NEED TO FIND RULES
        if (this.totalProb < 0.999) {
            //System.out.println("Incomplete RuleSet : " ); this.printRules();
            for (int l = 0 ; l < this.references.size(); l++) {
                RuleList r = closedList.getRuleByID(this.references.get(l)).getSameRuleSetRules(sList, closedList, rMap);

                for (int i = 0; i < r.size(); i++) {

                    insert = true;
                    // CHECK FOR MATCHES
                    for (int h = 0; h < this.references.size(); h++) {
                        if ( r.getRule(i).ruleMatch_exact(closedList.getRuleByID(this.references.get(h)))) {
                            insert = false;
                        }
                    }    
                    if (insert) { 
                            r.getRule(i).prec_occurrencies = closedList.getRuleByID(this.references.get(0)).prec_occurrencies;
                            closedList.addRule(r.getRule(i));
                            this.references.add(r.getRule(i).id);
                            this.totalProb = this.totalProb + r.getRule(i).getProb();
                            this.totalProb = Math.round(this.totalProb * 1000);
                            this.totalProb = this.totalProb/1000;

                            steps++;
                    }
                }
            }

        }
        
        return steps;
    }
    
    
    // Using HashMaps, we are able to quicly determine where
    // both Rules occur at the same time
    public ArrayList <Integer> getIntersection (RuleSet RS) {
        
        ArrayList <Integer> a = new ArrayList ();
        HashSet<Integer> map1 = new HashSet<>(this.indexesOfPrec);
        HashSet<Integer> map2 = new HashSet<>(RS.indexesOfPrec);
        
        map1.retainAll(map2);

        a.addAll(map1);
        return a;
    }
    
    
    // Chooses a Rule Pseudo-Randomly according to Probabilities of the RuleSet
    public Rule chooseRandomRule () {
        
        double a = Math.random();
        
        double c = 0.0;
        
        for (int i = 0; i < this.size(); i++) {
            
            c = c + this.getRule(i).getProb();
            
            if (c > a) {
                
                return this.getRule(i);
            }
        }
        
        return this.getRule(this.size()-1);
        
    }
    
    
    
    public void increase_RVLR (double value) {
        
        for (int i = 0; i < this.size(); i++) {
            
            this.getRule(i).increase_RVRL( value - this.getRule(i).get_RVRL());
        }
    }
    
    
    
    public double get_RVLR () {
        
        double res = 0.0;
        
        for (int i = 0; i < this.size(); i++) {
            
            res = res + this.getRule(i).get_RVRL();
        }
        
        
        return res;
    }
    
    
} // END FILE
