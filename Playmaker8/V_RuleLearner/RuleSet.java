
package V_RuleLearner;

import V_Sensors.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.concurrent.atomic.AtomicInteger;

/**
 *
 * @author virgile
 */
public class RuleSet {
    
    
    public ArrayList <Integer> references;
    public ArrayList <Integer> indexesOfPrec;
    public ArrayList <Integer> precedences;
    private RuleList rulelist;
    private SensorList sList;
    public double totalProb;
    public static AtomicInteger counter = new AtomicInteger();
    public int id;

    
    
    /*
        RULESET CONTAINS RULES WITH THE SAME PRECONDITION.
        WHEN CREATED, A UNIQUE ID IS GENERATED BY ATOMIC INTEGER.
        WHEN CREATED, TOTALPROB = -1, IT IS WHEN ADDING RULES TO RULESETS 
        THAT THE PROB IS CALCULATED.
    */
    public RuleSet (RuleList rulelist, SensorList sList) {
        
        this.references = new ArrayList();
        this.rulelist = rulelist;
        this.totalProb = -1.0;
        this.id = counter.incrementAndGet();
        this.indexesOfPrec = new ArrayList();
        this.precedences = new ArrayList ();
        this.sList = sList;
    }

    
    // BUILDS A RULESET FROM TWO RULESETS, IN ORDER TO MEASURE THE ERROR, AND
    // SET PRECEDENCE FROM ONE OVER ANOTHER , ArrayList precMatches
    public RuleSet (RuleSet RS1, RuleSet RS2, SensorList sList, SensorMap sMap, RuleMap rMap) {
        
        //System.out.println("\nCREATING COMBINATION RULESET FROM " + RS1.id + " & " + RS2.id + "...");
        
        this.references = new ArrayList();
        this.sList = sList;
        //this.indexesOfPrec =  precMatches;
        this.rulelist = RS1.rulelist;
        this.totalProb = 0.0;
        this.id = counter.incrementAndGet();
        Sensor precondition = RS1.getPrecursor().merge(RS2.getPrecursor());
        //this.indexesOfPrec = sList.indexesOfSensor(precondition);
        this.precedences = new ArrayList ();
        
        ArrayList <Integer> a = RS1.getSuccessor().detectCommonNonWilcardedIndexes(RS2.getSuccessor());
        //System.out.print("DOING size : " + RS1.indexesOfPrec.size() + " size2 : " + RS2.indexesOfPrec.size());
        //ArrayList <Integer> prec = RS1.getIntersection(RS2);
        //System.out.println("DONE");
        //System.out.println("INDEXES : " + a);
        Sensor root = new Sensor(RS1.getPrecursor().tokenMap);
        
        //System.out.print("Mapping " + RS1.id + " & " + RS2.id);
        
        //ArrayList <Integer> inter = RS1.getIntersection(RS2);
        
        //System.out.println(" OK (size : " + inter.size() + ").");
        
        //System.out.println("PRECONDITION : " + precondition);
        int num = a.size();
        boolean insert;
        
        if (num >= 1) {
            SensorList b = root.expand(a.get(0));
            //b.printList();
            if (num >= 2) { 
                
                for (int h = 2; h<=num; h++) {
                    
                    b.expandListAt(a.get(h-1));
                }
            }
            
            for (int j = 0; j < b.size(); j++) {
                insert = false;

                        // SEARCHING IN FIRST RULESET
                        for (int h1 = 0; h1 < RS1.size(); h1++) {
                            ///
                            if (RS1.getSuccessor(h1).sensorMatch(b.getSensor(j+1))) {
                                insert = true;
                                //System.out.println("1st RS good for " + b.getSensor(j+1));
                                break;
                            }
                        }
                        
                        // SEARCHING IN SECOND RULESET
                        if (!insert) {
                            
                            for (int h2 = 0; h2 < RS2.size(); h2++) {
                            
                                
                                if (RS2.getSuccessor(h2).sensorMatch(b.getSensor(j+1))) {
                                    insert = true;
                                    //System.out.println("2nd RS good for " + b.getSensor(j+1));
                                    break;
                                }
                                

                            }
                        }
                        
                        if (insert) {
                            
                            Rule rule = new Rule(precondition, b.getSensor(j+1), this.sList);
                            
                            rule.ruleset_id = this.id;
                            //rule.prec_occurrencies = sMap.getMatchingOccurencies(precondition);
                            
                            int aa = sMap.getMatchingOccurencies(precondition);
                            //int bb = sList.indexesOfSensor(precondition).size();
                            //int cc = inter.size();
                            //rule.occurrencies = sList.indexesOfRule(rule).size();
                            int tt  = rMap.getMatchingOccurencies(rule);
                            //int oo = sList.indexesOfRule(rule).size();
                            //rule.prec_occurrencies = inter.size();
////                            HashSet<Integer> map1 = new HashSet<>(sMap.getMatchingIndexes(b.getSensor(j+1)));
////                            HashSet<Integer> map2 = new HashSet<>(inter);
////                            HashSet<Integer> map3 = new HashSet<>();
////                            
////                            for (Integer ii : map1) {
////                                    map3.add(ii-1);
////                            }
////                            map2.retainAll(map3);
////                            
////                            int dd = map2.size();
                            
                            rule.prec_occurrencies = aa;
                            rule.occurrencies = tt;
                            
                            
                            //System.out.println("PrecOcc inter: " + cc + " // PrecOcc sMap : " + aa + " // PrecOcc sList : " + bb);
                            //System.out.println("Occ inter: " + dd + " // Occ rMap : " + tt + " // Occ sList : " + oo);
                            //rule.occurrencies = sList.indexesOfRule2(rule).size();   TOO LONG
                            //rule.occurrencies = sList.indexesOfRuleGivenPrec(rule, prec).size();
//                            ArrayList b12 = sMap.getMatchingIndexes(precondition);
//                            ArrayList b13 = sMap.getMatchingIndexes(b.getSensor(j+1));
//                            
//                            System.out.print("Called with b12 : " + b12.size() + " and b13 : " + b13.size());
//                            
//                            int h = 0;
//                            boolean finished = false;
//                            int b12_index = 0;
//                            int b12_value ;
//                            int b13_index = 0;
//                            int b13_value ;
//                            
//                           
//                            while (!finished) {
//                                
//                                System.out.println("b12_index : " + b12_index + " b13_index " + b13_index);
//                                
//                                if (b12.isEmpty() || b13.isEmpty()) {
//                                    break;
//                                }
//                                b12_value = (int) b12.get(b12_index);
//                                b13_value = (int) b13.get(b13_index);
//                                
//                                
//                                if (b12_value <= b13_value) {
//                                    
//                                    
//                                    
//                                    if (b12_value == (b13_value + 1))
//                                        h++;
//                                    
//                                    if(b12.size() > b12_index + 2)
//                                        b12_index++;
//                                }
//                                
//                                else {
//                                    
//                                    if (b12_value == (b13_value + 1))
//                                        h++;
//                                    
//                                    if(b13.size() > b13_index + 2)
//                                        b13_index++;
//                                }
//                                
//                                if ( (b12_index == (b12.size()-1)) && (b13_index != (b13.size()-1)) ) {
//                                    
//                                    while (b13_index != b13.size()-1) {
//                                        
//                                        b13_index ++;
//                                        b13_value = (int) b13.get(b13_index);
//                                        if (b12_value == (b13_value + 1))
//                                            h++;
//                                        
//                                    }
//                                }
//                                
//                                if ( (b12_index != (b12.size()-1)) && (b13_index == (b13.size()-1)) ) {
//                                    
//                                    while (b12_index != b12.size()-1) {
//                                        
//                                        b12_index ++;
//                                        b12_value = (int) b12.get(b12_index);
//                                        if (b12_value == (b12_value + 1))
//                                            h++;
//                                        
//                                    }
//                                } 
//                                
//                                if ( (b12_index == (b12.size()-1)) && (b13_index == (b13.size()-1)) )
//                                    finished = true;
//                            }
//
//                            System.out.println(" h : " + h);
                            //rule.occurrencies = h;
                            this.rulelist.addRule(rule);
                            this.add(rule);
                            //System.out.println("ADDED : " + rule.getPostcondition());
                            
                        }
                    

                    //b.printList();
                
            }
            
            }
        
        
        // UPDATING RULESET PROBABILITY
        if (this.size() > 0) {
            for (int i = 0; i < this.size(); i++) {

                totalProb = totalProb + this.getRule(i).getProb();
                totalProb = Math.round(totalProb * 1000);
                totalProb = totalProb/1000;
                
            }
        }
    }    


    
    public double getError (RuleSet RS) {
        
        double a = -0.0;
        
        
        if (RS.getSuccessor().numberOfNonWildcards() == this.getSuccessor().numberOfNonWildcards()) {
            for (int i = 0; i < RS.size(); i++) {

                for (int j = 0; j < this.size(); j++) {

                    if (this.getSuccessor(j).sensorMatch(RS.getSuccessor(i))) {

                        if (this.getRule(j).getProb() == 0.0) {

                            a = a + 0.5;
                            break;
                        }
                        else {
                            a = a + Math.abs(this.getRule(j).getProb() - RS.getRule(i).getProb());
                            break;
                        }
                    }
                }
            }

            return a;
        }
        
        else {
            
            for (int j = 0; j < this.size(); j++) {
            
                for (int i = 0; i < RS.size(); i++) {

                

                    if (this.getSuccessor(j).sensorMatch(RS.getSuccessor(i))) {

                        if (this.getRule(j).getProb() == 0.0) {

                            a = a + 0.5;
                            break;
                        }
                        else {
                            double b = RS.getRule(i).getProb();
                            
                            if (i+1 < RS.size()) {
                                for (int h = i+1; h < RS.size(); h++) {

                                    if (this.getSuccessor(j).sensorMatch(RS.getSuccessor(h)))
                                        b = b + RS.getRule(h).getProb();
                                }
                                a = a + Math.abs(this.getRule(j).getProb() - b);
                                break;
                            }
                        }

                    }
                }
            }

            return a;
        }
        
    }
    
    
    public boolean precedingOver (RuleSet RS1, RuleSet RS2) {
        
        return (this.getError(RS1) < this.getError(RS2));
    }
    
    public void add (int a) {
        
        references.add(a);
    }
    
    public void add (Rule r) {
        
//        if (this.indexesOfPrec.isEmpty()) {
//            
//            this.indexesOfPrec = this.sList.indexesOfSensor(this.getPrecursor());
//        }
        references.add(r.id);
    }
    
    
    public void initIndexes (SensorMap sMap) {
        
        if (this.size() >= 1)
        indexesOfPrec = sList.indexesOfSensor(this.getPrecursor());
        
//          if (this.size() >= 1)
//                indexesOfPrec = sMap.getMatchingIndexes(this.getPrecursor());
    }
    
    
    public Rule getRule (int i) {
        
        return this.rulelist.getRuleByID(this.references.get(i));
    }
    
    
    @Override
    public String toString () {
        
        return this.references.toString();
    }
    
    public int size () {
        
        return references.size();
    }
    
    
    public Sensor getPrecursor () {
        
        return this.rulelist.getRuleByID(this.references.get(0)).precondition;
    }
        
    public Sensor getPrecursorWithoutId () {
        
        return this.rulelist.getRuleByID(this.references.get(0)).precondition;
    }    
    
    public int getPrecursorOccurrencies () {
        
        return this.rulelist.getRuleByID(this.references.get(0)).prec_occurrencies;
    }
    
    public Sensor getSuccessor () {
        
        return getSuccessor(0);
    }
    
    // WORKS WITH IDS
    public Sensor getSuccessor (int i) {
        
        return this.rulelist.getRuleByID(this.references.get(i)).postcondition;
    }    
    
//    // WORKS WITH POSITION
//    public Sensor getSuccessor (int i) {
//        
//        return this.rulelist.getRuleByID(this.references.get(i)).postcondition;
//    }        
    
    
    
    /* 
        RETURNS THE INDEXES OF NON-WILCARDED OUTPUT.
    */
    public ArrayList <Integer> detectNonWildcardedSpots () {
        
        ArrayList <Integer> res = new ArrayList (); 
        
        for (int i = 0; i < this.getSuccessor().size(); i++) {
            
            if (this.getSuccessor().getToken(i).isNotWildcard())
                res.add(i);
        }
        
        return res;       
    }

    
    public void print () {
        
        System.out.println("PRINTING RULESET ID : " + this.id + " (" + this.size() + ") entries.");
        for (int i = 0; i < this.size(); i++) {
            
            System.out.println("Ruleset " + (i+1) + " : " + references.get(i) );
        }
        System.out.println("Total Prob : " + this.totalProb);
    }
 
    
    /*
        MORE DETAILED WAY TO PRINT A RULESET, PRINTING RULES CONTENT INSTEAD OF IDS
    */
    public void printRules () {
        
        System.out.println("PRINTING RULESET ID : " + this.id + " (" + this.size() + ") entries.");
        for (int i = 0; i < this.size(); i++) {
            
            System.out.println("Rule " + (i+1) + " (ID " + references.get(i) + ") : " + this.rulelist.getRuleByID(references.get(i)) + " Prob : " + this.rulelist.getRuleByID(references.get(i)).getProb() + " TIMES " + this.rulelist.getRuleByID(references.get(i)).occurrencies + " PREC " + this.rulelist.getRuleByID(references.get(i)).prec_occurrencies);
        }
        System.out.println("Total Prob : " + this.totalProb);
        System.out.println("Precedences : " + this.precedences);
    }
 
    
    /*
        CHECKS IF A RULESET IS CONFLICTING WITH ANOTHER ONE BY CHECKING SUCCESSORS OUTPUT
    */
    public boolean isConflicting (RuleSet ruleset) {
        
        if (this.id == ruleset.id)
            return false; 
        
        if (!this.getPrecursor().sensorMatch(ruleset.getPrecursor()))
            return false;
        
        
        for (int i = 0; i < this.getSuccessor().size(); i++) {
            
            if ((this.getSuccessor().getToken(i).isNotWildcard()) && (ruleset.getSuccessor().getToken(i).isNotWildcard())) {
                
                //if (this.getPrecursorOccurrencies() <= ruleset.getPrecursorOccurrencies())
                    return true; 
            }
        }
        
        
        return false;
    }
    
    
    /*
        MERGING SENSORS FROM RULESETS IN ORDER TO GET ALL THE POSSIBLE COMBINATIONS. 
    
        NO CLEANING OR PRUNING IS DONE HERE, WHICH MEANS SOME "IMPOSSIBLE" RULES CAN OCCUR.       
    */
    public SensorList outputsFromRuleSets (RuleSet ruleset2) {
        
        SensorList res = new SensorList (); 

        for (int i = 0; i < this.size(); i++) {
            
            
            for (int j = 0; j < ruleset2.size(); j++) {
                
                Sensor a = this.getSuccessor(i).merge(ruleset2.getSuccessor(j));
                res.addSensor(a);
            }
        }
        
        return res;
    }

    
    /*
        GETS PROBS OF THE OUTPUTSTATES
    */
    public ArrayList <Double> outputsProbFromRuleSets (RuleSet ruleset2) {
        
        ArrayList <Double> res = new ArrayList <> (); 
        double a;
        
        for (int i = 0; i < this.size(); i++) {
            
            
            for (int j = 0; j < ruleset2.size(); j++) {
                
                a = this.getRule(i).getProb();
                a = a * ruleset2.getRule(j).getProb();
                res.add(a);
            }
        }
        
        return res;
    } 
    
    
    
    public SensorList outputsFromRuleSets () {
        
        SensorList res = new SensorList (); 

        for (int i = 0; i < this.size(); i++) {
            
            
            for (int j = 0; j < sList.size(); j++) {
                
                Sensor a = this.getSuccessor(i).merge(sList.getSensor(j+1));
                res.addSensor(a);
                
            }
        }
        
        return res;
    }
    
    
    
    /*
        CONSOLIDATES A RULESET BY ADDING MISSING RULES, 
        IN ORDER TO GET A "COMPLETE" RULESET, I.E. WITH A TOTAL PROB OF 1. 
        
        THIS PROCESS TAKES A HUGE TIME, I THINK IT COULD TAKE MUCH LESS TIME 
        WITH A BIT OF OPTIMIZATION. 
    */
    public int consolidate (RuleList closedList, RuleMap rMap) {
        
        int steps = 0;
        boolean insert = true;
        // IF THE RULESET IS ALREADY COMPLETE, NO NEED TO FIND RULES
        if (this.totalProb < 0.98) {

            for (int l = 0 ; l < this.references.size(); l++) {
                RuleList r = closedList.getRuleByID(this.references.get(l)).getSameRuleSetRules(sList, closedList, rMap);

                for (int i = 0; i < r.size(); i++) {

                    insert = true;
                    // CHECK FOR MATCHES
                    for (int h = 0; h < this.references.size(); h++) {
                        if ( r.getRule(i).ruleMatch_exact(closedList.getRuleByID(this.references.get(h)))) {
                            insert = false;
                        }
                    }    
                    if (insert) { 
                            r.getRule(i).prec_occurrencies = closedList.getRuleByID(this.references.get(0)).prec_occurrencies;
                            closedList.addRule(r.getRule(i));
                            this.references.add(r.getRule(i).id);
                            this.totalProb = this.totalProb + r.getRule(i).getProb();
                            this.totalProb = Math.round(this.totalProb * 1000);
                            this.totalProb = this.totalProb/1000;

                            steps++;
                    }


                    //System.out.println("CREATED RULE (ID " + r.getRule(i).id + ") : " + r.getRule(i) + " prob : " + r.getRule(i).getProb());
                }
            }

        }
        
        return steps;
    }
    
    
    public ArrayList <Integer> getIntersection (RuleSet RS) {
        
        ArrayList <Integer> a = new ArrayList ();
        HashSet<Integer> map1 = new HashSet<>(this.indexesOfPrec);
        HashSet<Integer> map2 = new HashSet<>(RS.indexesOfPrec);
        
////        //HashMap<Integer, Integer> map2 = new HashMap<>();
////        
////        for (int i = 0; i < this.indexesOfPrec.size(); i++) {
////            
////                map1.put(i, this.indexesOfPrec.get(i));
////
////        }
////        
////        for (int i = 0; i < RS.indexesOfPrec.size(); i++) {
////            
////                map2.put(i, RS.indexesOfPrec.get(i));
////
////        }  
        
        
        map1.retainAll(map2);
//        for (int t = 0; t < map1.size(); t++) {
//            
//            if (map2.containsValue(map1.get(t)+1))
//                a.add(map1.get(t));
//        }
        a.addAll(map1);
        return a;
    }
    
    
    
    public Rule chooseRandomRule () {
        
        double a = Math.random();
        
        double c = 0.0;
        
        //System.out.println("Choosing Random Rule : " + a);
        
        for (int i = 0; i < this.size(); i++) {
            
            c = c + this.getRule(i).getProb();
            
            if (c > a) {
                //System.out.println("Rule chosen : " + this.getRule(i));
                return this.getRule(i);
            }
        }
        
        return this.getRule(this.size()-1);
        
        
        
    }
    
    
} // END FILE
